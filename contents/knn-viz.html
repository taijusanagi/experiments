<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="updated" content="2025-04-16T23:55:26.257Z" />
    <meta name="created" content="2025-04-16T00:16:04.150Z" />
    <meta charset="UTF-8" />
    <title>K-Nearest Neighbors (KNN) Viz with Generative Sound</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #15181f;
        color: #d0d8e8;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }
      #ui-container {
        position: absolute;
        top: 15px;
        left: 15px;
        background: rgba(15, 20, 30, 0.85);
        padding: 15px 20px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: flex-start;
        border: 1px solid rgba(80, 100, 130, 0.5);
        max-width: 250px;
        z-index: 10;
      }
      #ui-container label,
      #ui-container .label-like {
        display: block;
        margin-bottom: 5px;
        color: #c0d0e0;
        font-size: 0.95em;
        font-weight: 500;
      }
      #kValueLabel,
      #playSpeedValueLabel {
        margin-left: 10px;
        min-width: 45px;
        display: inline-block;
        font-weight: bold;
        color: #e0e8f8;
        text-align: right;
      }
      #kSlider,
      #playSpeedSlider {
        vertical-align: middle;
        cursor: pointer;
        accent-color: #70a0d0;
        width: 150px;
      }
      .radio-group label {
        display: inline-block;
        margin-right: 15px;
        font-size: 0.9em;
        cursor: pointer;
      }
      .radio-group input[type="radio"] {
        vertical-align: middle;
        margin-right: 4px;
        accent-color: #70a0d0;
        cursor: pointer;
      }
      #ui-container hr {
        border: none;
        border-top: 1px solid rgba(80, 100, 130, 0.5);
        width: 100%;
        margin: 5px 0;
      }
      #audio-toggle-button {
        position: absolute;
        top: 15px;
        right: 15px;
        background-color: rgba(50, 60, 80, 0.9);
        color: #e0e8f8;
        padding: 8px 12px;
        border-radius: 5px;
        font-size: 0.8em;
        text-align: center;
        cursor: pointer;
        z-index: 100;
        border: 1px solid rgba(100, 120, 160, 0.7);
        min-width: 80px;
      }
      #audio-toggle-button:hover {
        background-color: rgba(70, 80, 100, 0.95);
      }
      @media (max-width: 600px) {
        #ui-container {
          display: none;
        }
        #audio-toggle-button {
          font-size: 0.75em;
          padding: 6px 10px;
          min-width: 70px;
        }
      }
    </style>
  </head>
  <body>
    <div id="ui-container">
      <div>
        <label for="kSlider">Neighbors (k):</label>
        <input type="range" id="kSlider" min="1" max="15" value="3" step="1" />
        <span id="kValueLabel">3</span>
      </div>
      <div>
        <label for="playSpeedSlider">Play Speed:</label>
        <input
          type="range"
          id="playSpeedSlider"
          min="0.5"
          max="2.0"
          value="1.0"
          step="0.05"
        />
        <span id="playSpeedValueLabel">1.00x</span>
      </div>
      <hr />
      <div>
        <span class="label-like">Training Data Distribution:</span>
        <div class="radio-group">
          <label>
            <input type="radio" name="dataMode" value="grouped" checked />
            Grouped
          </label>
          <label>
            <input type="radio" name="dataMode" value="random" /> Random
          </label>
        </div>
      </div>
    </div>

    <div id="audio-toggle-button">Enable Sound</div>

    <script>
      let scene, camera, renderer, controls;
      const trainingPoints = [];
      let fallingTestPoint = null;
      const voteLines = [];
      let boundaryPlaneMesh = null;
      let kValue = 3;
      let trainingDataMode = "grouped";

      let playSpeedMultiplier = 1.0;
      const baseFallSpeed = 0.15;
      const baseDisplayTime = 1000;
      let currentFallSpeed = baseFallSpeed;
      let currentDisplayTime = baseDisplayTime;
      const minDisplayTime = 200;

      const initialSeed = 123456;
      let currentSeed = initialSeed;
      function resetSeed() {
        currentSeed = initialSeed;
      }
      function seededRandom() {
        const a = 1103515245,
          c = 12345,
          m = Math.pow(2, 31);
        currentSeed = (a * currentSeed + c) % m;
        return currentSeed / m;
      }

      const classColors = {
        0: 0xff8080,
        1: 0x80ff80,
        2: 0x8080ff,
        testPredicted0: 0xffb0b0,
        testPredicted1: 0xb0ffb0,
        testPredicted2: 0xb0b0ff,
        testFalling: 0xffffff,
        testLandedNeutral: 0xcccccc,
        boundary0: 0xd9aaaa,
        boundary1: 0xaad9aa,
        boundary2: 0xaaaad9,
        boundaryUndefined: 0x505055,
      };
      const pointSize = 0.15;
      const spawnBounds = { xMin: -8, xMax: 8, zMin: -8, zMax: 8, yStart: 10 };
      const boundaryArea = {
        width: 20,
        height: 20,
        segmentsX: 80,
        segmentsZ: 80,
      };
      const clusterCenters = {
        0: new THREE.Vector3(-5, pointSize, -4),
        1: new THREE.Vector3(5, pointSize, -4),
        2: new THREE.Vector3(0, pointSize, 6),
      };
      const clusterSpread = 3.5;
      const randomSpread = 9.0;

      let audioContext;
      let isAudioReady = false;
      let isSoundMuted = true;
      const baseVolume = 0.18;

      const Notes = {
        C4: 261.63,
        D4: 293.66,
        E4: 329.63,
        F4: 349.23,
        G4: 392.0,
        A4: 440.0,
        B4: 493.88,
        C5: 523.25,
        D5: 587.33,
        E5: 659.25,
        F5: 698.46,
        G5: 783.99,
        A5: 880.0,
        B5: 987.77,
        C6: 1046.5,
        D6: 1174.66,
        E6: 1318.51,
        F6: 1396.91,
        G6: 1567.98,
        A6: 1760.0,
        B6: 1975.53,
      };

      const scaleNotes = {
        0: [Notes["C5"], Notes["E5"], Notes["G5"], Notes["A5"], Notes["C6"]],
        1: [Notes["G4"], Notes["B4"], Notes["D5"], Notes["E5"], Notes["G5"]],
        2: [Notes["F5"], Notes["A5"], Notes["C6"], Notes["D6"], Notes["F6"]],
      };

      const beamOscillatorTypes = {
        0: "sine",
        1: "triangle",
        2: "sine",
      };

      const beamSoundBaseSettings = {
        baseDuration: 0.06,
        volMult: 0.9,
        minDuration: 0.03,
      };
      const beamDistanceEffect = { maxDist: 18.0 };

      const landingSoundSettings = {
        freq: 110,
        duration: 0.15,
        type: "sine",
        volMult: 1.0,
      };
      const resultSoundSettings = {
        0: { freq: Notes["C4"], duration: 0.6, type: "sine", volMult: 1.0 },
        1: { freq: Notes["E4"], duration: 0.6, type: "sine", volMult: 1.0 },
        2: { freq: Notes["G4"], duration: 0.6, type: "sine", volMult: 1.0 },
        "-1": { freq: 160, duration: 0.4, type: "square", volMult: 0.7 },
      };

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 13, 15);
        camera.lookAt(0, 1, 0);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x15181f);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xa0b0c0, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 15, 8);
        scene.add(directionalLight);
        const hemisphereLight = new THREE.HemisphereLight(
          0xccccff,
          0x606090,
          0.4
        );
        scene.add(hemisphereLight);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2 + 0.2;
        controls.minDistance = 2;
        controls.maxDistance = 50;
        controls.target.set(0, 1, 0);
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;

        createDecisionBoundaryPlane();

        document
          .getElementById("kSlider")
          .addEventListener("input", handleKChange);
        setupPlaySpeedSlider();
        setupDataModeRadios();

        setupAudioToggleButton();

        window.addEventListener("resize", onWindowResize);

        resetSeed();
        regenerateTrainingData(true);
      }

      function initAudioContext() {
        if (!audioContext) {
          try {
            window.AudioContext =
              window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            isAudioReady = audioContext.state === "running";

            if (audioContext.state === "suspended") {
              // Return promise to handle async resume
              return audioContext
                .resume()
                .then(() => {
                  isAudioReady = true;
                  console.log("AudioContext resumed.");
                  return true; // Indicate success
                })
                .catch((e) => {
                  console.error("Error resuming AudioContext:", e);
                  isAudioReady = false;
                  return false; // Indicate failure
                });
            } else if (isAudioReady) {
              console.log("AudioContext already running.");
              return Promise.resolve(true); // Already ready
            }
          } catch (e) {
            console.error(
              "Web Audio API is not supported or context creation failed:",
              e
            );
            isAudioReady = false;
            return Promise.resolve(false); // Indicate failure
          }
        } else if (audioContext.state === "suspended") {
          // If context exists but is suspended, try resuming
          return audioContext
            .resume()
            .then(() => {
              isAudioReady = true;
              console.log("AudioContext resumed.");
              return true;
            })
            .catch((e) => {
              console.error("Error resuming existing AudioContext:", e);
              isAudioReady = false;
              return false;
            });
        }
        // If context exists and is running
        return Promise.resolve(true);
      }

      function setupAudioToggleButton() {
        const button = document.getElementById("audio-toggle-button");
        if (!button) return;

        button.addEventListener("click", async () => {
          // Always try to initialize/resume first on click if not ready
          if (!isAudioReady) {
            const success = await initAudioContext();
            if (success) {
              isSoundMuted = false; // Unmute after successful init/resume
              button.textContent = "Mute Sound";
              playTone(440, 0.1, "sine", 0.1); // Play confirmation sound
            } else {
              // Handle case where context couldn't start/resume
              button.textContent = "Enable Sound"; // Keep initial text
              isSoundMuted = true; // Stay muted
              // Optionally show an error message to the user
            }
          } else {
            // If audio is ready, just toggle mute state
            isSoundMuted = !isSoundMuted;
            button.textContent = isSoundMuted ? "Unmute Sound" : "Mute Sound";
            // Optionally play a subtle click/toggle sound
            if (!isSoundMuted) {
              playTone(660, 0.05, "triangle", 0.1);
            } else {
              playTone(330, 0.05, "triangle", 0.1);
            }
          }
        });
      }

      function playTone(freq, durationSec, type = "sine", volMultiplier = 1.0) {
        if (
          !isAudioReady ||
          isSoundMuted ||
          !audioContext ||
          audioContext.state !== "running"
        ) {
          return;
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

        const volume = baseVolume * volMultiplier;
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.0001,
          audioContext.currentTime + durationSec
        );

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + durationSec);

        setTimeout(() => {
          if (oscillator && typeof oscillator.disconnect === "function")
            oscillator.disconnect();
          if (gainNode && typeof gainNode.disconnect === "function")
            gainNode.disconnect();
        }, durationSec * 1000 + 150);
      }

      function setupPlaySpeedSlider() {
        const playSpeedSlider = document.getElementById("playSpeedSlider");
        const playSpeedValueLabel = document.getElementById(
          "playSpeedValueLabel"
        );
        if (!playSpeedSlider || !playSpeedValueLabel) return;
        playSpeedMultiplier = parseFloat(playSpeedSlider.value);
        currentFallSpeed = baseFallSpeed * playSpeedMultiplier;
        currentDisplayTime = Math.max(
          minDisplayTime,
          baseDisplayTime / playSpeedMultiplier
        );
        playSpeedValueLabel.textContent = playSpeedMultiplier.toFixed(2) + "x";
        playSpeedSlider.addEventListener("input", (event) => {
          playSpeedMultiplier = parseFloat(event.target.value);
          currentFallSpeed = baseFallSpeed * playSpeedMultiplier;
          currentDisplayTime = Math.max(
            minDisplayTime,
            baseDisplayTime / playSpeedMultiplier
          );
          playSpeedValueLabel.textContent =
            playSpeedMultiplier.toFixed(2) + "x";
        });
      }

      function setupDataModeRadios() {
        document.querySelectorAll('input[name="dataMode"]').forEach((radio) => {
          if (radio && radio.parentElement) {
            radio.addEventListener("change", (event) => {
              if (event.target.checked) {
                trainingDataMode = event.target.value;
                regenerateTrainingData(false);
              }
            });
          }
        });
      }

      function createDecisionBoundaryPlane() {
        const geometry = new THREE.PlaneGeometry(
          boundaryArea.width,
          boundaryArea.height,
          boundaryArea.segmentsX,
          boundaryArea.segmentsZ
        );
        const material = new THREE.MeshBasicMaterial({
          vertexColors: true,
          side: THREE.DoubleSide,
        });
        boundaryPlaneMesh = new THREE.Mesh(geometry, material);
        boundaryPlaneMesh.rotation.x = -Math.PI / 2;
        boundaryPlaneMesh.position.y = -0.1;
        scene.add(boundaryPlaneMesh);
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        const defaultColor = new THREE.Color(classColors.boundaryUndefined);
        for (let i = 0; i < geometry.attributes.position.count; i++) {
          colors.set([defaultColor.r, defaultColor.g, defaultColor.b], i * 3);
        }
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      }

      function handleKChange(event) {
        const kValueLabel = document.getElementById("kValueLabel");
        if (!kValueLabel) return;
        kValue = parseInt(event.target.value, 10);
        kValueLabel.textContent = kValue;
        setTimeout(() => {
          updateDecisionBoundary();
        }, 10);
      }

      function regenerateTrainingData(isInitialSetup = false) {
        clearTrainingPoints();
        cleanupFallingPoint();
        clearVoteLines();
        resetSeed();
        addInitialTrainingData(20);
        setTimeout(() => {
          updateDecisionBoundary();
          spawnFallingTestPoint();
        }, 50);
      }

      function clearTrainingPoints() {
        trainingPoints.forEach((tp) => {
          if (tp.mesh) {
            scene.remove(tp.mesh);
            tp.mesh.geometry?.dispose();
            tp.mesh.material?.dispose();
          }
        });
        trainingPoints.length = 0;
      }

      function cleanupFallingPoint() {
        const pointToClean = fallingTestPoint;
        if (pointToClean && pointToClean.mesh) {
          clearTimeout(pointToClean.removeTimer);
          pointToClean.aborted = true;
          scene.remove(pointToClean.mesh);
          pointToClean.mesh.geometry?.dispose();
          pointToClean.mesh.material?.dispose();
        }
        if (fallingTestPoint === pointToClean) {
          fallingTestPoint = null;
        }
      }

      function addInitialTrainingData(pointsPerClass) {
        const totalPoints = pointsPerClass * 3;
        for (let i = 0; i < totalPoints; i++) {
          let pos, classId;
          if (trainingDataMode === "grouped") {
            classId = Math.floor(i / pointsPerClass);
            const center = clusterCenters[classId];
            const offsetX = (seededRandom() - 0.5) * clusterSpread * 2;
            const offsetZ = (seededRandom() - 0.5) * clusterSpread * 2;
            pos = new THREE.Vector3(
              center.x + offsetX,
              pointSize,
              center.z + offsetZ
            );
          } else {
            const x = (seededRandom() - 0.5) * randomSpread * 2;
            const z = (seededRandom() - 0.5) * randomSpread * 2;
            pos = new THREE.Vector3(x, pointSize, z);
            classId = Math.floor(seededRandom() * 3);
          }
          addPoint(pos, classId);
        }
        updateKSliderMax();
      }

      function addPoint(position, classId) {
        const geometry = new THREE.SphereGeometry(pointSize, 20, 20);
        const color = classColors[classId];
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.2,
          roughness: 0.6,
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        sphere.position.y = Math.max(sphere.position.y, pointSize);
        scene.add(sphere);
        trainingPoints.push({
          position: sphere.position,
          class: classId,
          mesh: sphere,
        });
        return sphere;
      }

      function spawnFallingTestPoint() {
        cleanupFallingPoint();
        clearVoteLines();
        const x =
          (seededRandom() - 0.5) * (spawnBounds.xMax - spawnBounds.xMin);
        const z =
          (seededRandom() - 0.5) * (spawnBounds.zMax - spawnBounds.zMin);
        const startPos = new THREE.Vector3(x, spawnBounds.yStart, z);
        const geometry = new THREE.SphereGeometry(pointSize * 1.1, 20, 20);
        const material = new THREE.MeshStandardMaterial({
          color: classColors.testFalling,
          metalness: 0.3,
          roughness: 0.5,
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(startPos);
        scene.add(sphere);
        fallingTestPoint = {
          mesh: sphere,
          targetY: pointSize,
          falling: true,
          removeTimer: null,
          aborted: false,
        };
      }

      function getKNNPrediction(testPosition, k) {
        if (trainingPoints.length === 0)
          return { predictedClass: -1, neighbors: [] };
        const distances = trainingPoints.map((trainPoint) => ({
          point: trainPoint,
          distance: testPosition.distanceTo(trainPoint.position),
        }));
        distances.sort((a, b) => a.distance - b.distance);
        const currentK = Math.min(k, trainingPoints.length);
        const neighbors = distances.slice(0, currentK);
        if (neighbors.length === 0)
          return { predictedClass: -1, neighbors: [] };
        const votes = { 0: 0, 1: 0, 2: 0 };
        neighbors.forEach((neighbor) => votes[neighbor.point.class]++);
        let predictedClass = -1,
          maxVotes = 0,
          tiedClasses = [];
        for (const classId in votes) {
          if (votes[classId] > maxVotes) {
            maxVotes = votes[classId];
            predictedClass = parseInt(classId, 10);
            tiedClasses = [predictedClass];
          } else if (votes[classId] === maxVotes) {
            tiedClasses.push(parseInt(classId, 10));
          }
        }
        if (tiedClasses.length > 1) {
          for (let i = 0; i < neighbors.length; i++) {
            if (tiedClasses.includes(neighbors[i].point.class)) {
              predictedClass = neighbors[i].point.class;
              break;
            }
          }
          if (!tiedClasses.includes(predictedClass)) {
            predictedClass = Math.min(...tiedClasses);
          }
        }
        return { predictedClass, neighbors: neighbors.map((n) => n.point) };
      }

      function updateDecisionBoundary() {
        if (
          !boundaryPlaneMesh?.geometry?.attributes?.position ||
          !boundaryPlaneMesh?.geometry?.attributes?.color
        )
          return;
        const geometry = boundaryPlaneMesh.geometry;
        const positions = geometry.attributes.position;
        const colors = geometry.attributes.color;
        const tempTestPos = new THREE.Vector3();
        const matrixWorld = boundaryPlaneMesh.matrixWorld;
        const hasPoints = trainingPoints.length > 0;
        const currentKValue = document.getElementById("kSlider")
          ? parseInt(document.getElementById("kSlider").value, 10)
          : kValue;
        for (let i = 0; i < positions.count; i++) {
          tempTestPos.fromBufferAttribute(positions, i);
          tempTestPos.applyMatrix4(matrixWorld);
          tempTestPos.y = 0;
          let predictedClass = -1;
          if (hasPoints) {
            predictedClass = getKNNPrediction(
              tempTestPos,
              currentKValue
            ).predictedClass;
          }
          let boundaryColor;
          switch (predictedClass) {
            case 0:
              boundaryColor = classColors.boundary0;
              break;
            case 1:
              boundaryColor = classColors.boundary1;
              break;
            case 2:
              boundaryColor = classColors.boundary2;
              break;
            default:
              boundaryColor = classColors.boundaryUndefined;
          }
          const colorObj = new THREE.Color(boundaryColor);
          colors.setXYZ(i, colorObj.r, colorObj.g, colorObj.b);
        }
        colors.needsUpdate = true;
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function classifyLandedPoint(landedPointData) {
        if (!landedPointData || landedPointData.aborted) {
          return;
        }
        const currentPointData = landedPointData;
        const landedPosition = currentPointData.mesh.position.clone();
        clearVoteLines();

        playTone(
          landingSoundSettings.freq,
          landingSoundSettings.duration,
          landingSoundSettings.type,
          landingSoundSettings.volMult
        );

        const tempLineMaterial = new THREE.LineBasicMaterial({
          color: 0x00ffff,
          transparent: false,
          linewidth: 2,
        });
        const sequentialDelay = 150;

        if (trainingPoints.length > 0) {
          for (const trainPoint of trainingPoints) {
            if (currentPointData.aborted) {
              break;
            }
            const points = [landedPosition, trainPoint.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const tempLine = new THREE.Line(geometry, tempLineMaterial);
            scene.add(tempLine);

            const scale = scaleNotes[trainPoint.class] || scaleNotes[0];
            const oscillatorType =
              beamOscillatorTypes[trainPoint.class] || "sine";

            const dist = landedPosition.distanceTo(trainPoint.position);
            const maxDist = beamDistanceEffect.maxDist;
            const distFactor = Math.min(dist, maxDist) / maxDist;
            const normalizedDist = Math.pow(distFactor, 0.6);

            const scaleIndex = Math.min(
              scale.length - 1,
              Math.floor(normalizedDist * scale.length)
            );
            const targetFreq = scale[scaleIndex];

            const baseDuration = beamSoundBaseSettings.baseDuration;
            const targetDuration = Math.max(
              beamSoundBaseSettings.minDuration,
              baseDuration * (0.7 + 0.6 * normalizedDist)
            );

            playTone(
              targetFreq,
              targetDuration,
              oscillatorType,
              beamSoundBaseSettings.volMult
            );

            const calculatedDelay = sequentialDelay / playSpeedMultiplier;
            await delay(calculatedDelay);

            if (currentPointData.aborted) {
              scene.remove(tempLine);
              tempLine.geometry?.dispose();
              break;
            }
            scene.remove(tempLine);
            tempLine.geometry?.dispose();
          }
        }
        tempLineMaterial.dispose();

        if (currentPointData.aborted) {
          clearVoteLines();
          return;
        }

        const classificationResult = getKNNPrediction(landedPosition, kValue);
        const { predictedClass, neighbors } = classificationResult;

        const resultSound =
          resultSoundSettings[predictedClass] || resultSoundSettings["-1"];
        playTone(
          resultSound.freq,
          resultSound.duration,
          resultSound.type,
          resultSound.volMult
        );

        if (predictedClass !== -1) {
          if (currentPointData.mesh?.material) {
            currentPointData.mesh.material.color.set(
              classColors[`testPredicted${predictedClass}`]
            );
          }
        } else {
          if (currentPointData.mesh?.material) {
            currentPointData.mesh.material.color.set(
              classColors.testLandedNeutral
            );
          }
        }

        drawVoteLines(landedPosition, neighbors);

        currentPointData.removeTimer = setTimeout(() => {
          if (!currentPointData.aborted) {
            spawnFallingTestPoint();
          }
        }, currentDisplayTime);
      }

      function drawVoteLines(targetPosition, neighborPoints) {
        clearVoteLines();
        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 1.5,
          transparent: false,
        });
        neighborPoints.forEach((neighbor) => {
          const points = [targetPosition.clone(), neighbor.position.clone()];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geometry, material.clone());
          scene.add(line);
          voteLines.push(line);
        });
      }

      function clearVoteLines() {
        voteLines.forEach((line) => {
          scene.remove(line);
          line.geometry?.dispose();
          line.material?.dispose();
        });
        voteLines.length = 0;
      }

      function updateKSliderMax() {
        const kSlider = document.getElementById("kSlider");
        const kValueLabel = document.getElementById("kValueLabel");
        if (!kSlider || !kValueLabel) return;
        const maxK = Math.max(1, trainingPoints.length);
        kSlider.max = maxK;
        let currentSliderValue = parseInt(kSlider.value);
        if (currentSliderValue > maxK) {
          kSlider.value = maxK;
          currentSliderValue = maxK;
        }
        if (kValue > maxK) {
          kValue = maxK;
        } else if (trainingPoints.length === 0) {
          kSlider.value = 1;
          currentSliderValue = 1;
          kValue = 1;
        }
        kValue = currentSliderValue;
        kValueLabel.textContent = kValue;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate(time) {
        requestAnimationFrame(animate);
        controls.update();

        const point = fallingTestPoint;
        if (point && point.falling) {
          const currentY = point.mesh.position.y;
          const targetY = point.targetY;
          if (currentY > targetY) {
            point.mesh.position.y = Math.max(
              targetY,
              currentY - currentFallSpeed
            );
          }

          if (point.mesh.position.y <= targetY && point.falling) {
            point.mesh.position.y = targetY;
            point.falling = false;
            if (!point.aborted) {
              classifyLandedPoint(point);
            }
          }
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
