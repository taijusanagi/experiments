<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="updated" content="2025-04-16T19:02:35.816Z" />
    <meta name="created" content="2025-04-16T00:16:04.150Z" />
    <meta charset="UTF-8" />
    <title>K-Nearest Neighbors (KNN) Viz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #15181f;
        color: #d0d8e8;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }
      #ui-container {
        position: absolute;
        top: 15px;
        left: 15px;
        background: rgba(15, 20, 30, 0.85);
        padding: 15px 20px;
        border-radius: 8px;
        display: flex; /* Default display */
        flex-direction: column;
        gap: 15px;
        align-items: flex-start;
        border: 1px solid rgba(80, 100, 130, 0.5);
        max-width: 250px;
      }
      #ui-container label,
      #ui-container .label-like {
        display: block;
        margin-bottom: 5px;
        color: #c0d0e0;
        font-size: 0.95em;
        font-weight: 500;
      }
      #kValueLabel,
      #playSpeedValueLabel {
        margin-left: 10px;
        min-width: 45px;
        display: inline-block;
        font-weight: bold;
        color: #e0e8f8;
        text-align: right;
      }
      #kSlider,
      #playSpeedSlider {
        vertical-align: middle;
        cursor: pointer;
        accent-color: #70a0d0;
        width: 150px;
      }
      .radio-group label {
        display: inline-block;
        margin-right: 15px;
        font-size: 0.9em;
        cursor: pointer;
      }
      .radio-group input[type="radio"] {
        vertical-align: middle;
        margin-right: 4px;
        accent-color: #70a0d0;
        cursor: pointer;
      }
      #ui-container hr {
        border: none;
        border-top: 1px solid rgba(80, 100, 130, 0.5);
        width: 100%;
        margin: 5px 0;
      }

      /* Media Query to hide UI on small screens */
      @media (max-width: 600px) {
        /* Adjust breakpoint as needed */
        #ui-container {
          display: none; /* Hide the entire panel */
        }
      }
    </style>
  </head>
  <body>
    <div id="ui-container">
      <div>
        <label for="kSlider">Neighbors (k):</label>
        <input type="range" id="kSlider" min="1" max="15" value="3" step="1" />
        <span id="kValueLabel">3</span>
      </div>

      <div>
        <label for="playSpeedSlider">Play Speed:</label>
        <input
          type="range"
          id="playSpeedSlider"
          min="0.25"
          max="4.0"
          value="1.0"
          step="0.05"
        />
        <span id="playSpeedValueLabel">1.00x</span>
      </div>

      <hr />

      <div>
        <span class="label-like">Training Data Distribution:</span>
        <div class="radio-group">
          <label>
            <input type="radio" name="dataMode" value="grouped" checked />
            Grouped
          </label>
          <label>
            <input type="radio" name="dataMode" value="random" /> Random
          </label>
        </div>
      </div>
    </div>

    <script>
      let scene, camera, renderer, controls;
      const trainingPoints = [];
      let fallingTestPoint = null;
      const voteLines = [];
      let boundaryPlaneMesh = null;
      let kValue = 3;
      let trainingDataMode = "grouped";

      let playSpeedMultiplier = 1.0;
      const baseFallSpeed = 0.05;
      const baseDisplayTime = 3000;
      let currentFallSpeed = baseFallSpeed;
      let currentDisplayTime = baseDisplayTime;
      const minDisplayTime = 200;

      const initialSeed = 123456;
      let currentSeed = initialSeed;
      function resetSeed() {
        currentSeed = initialSeed;
        console.log("PRNG Seed Reset to", currentSeed);
      }
      function seededRandom() {
        const a = 1103515245,
          c = 12345,
          m = Math.pow(2, 31);
        currentSeed = (a * currentSeed + c) % m;
        return currentSeed / m;
      }

      const classColors = {
        0: 0xff8080,
        1: 0x80ff80,
        2: 0x8080ff,
        testPredicted0: 0xffb0b0,
        testPredicted1: 0xb0ffb0,
        testPredicted2: 0xb0b0ff,
        testFalling: 0xffffff,
        testLandedNeutral: 0xcccccc,
        boundary0: 0xd9aaaa,
        boundary1: 0xaad9aa,
        boundary2: 0xaaaad9,
        boundaryUndefined: 0x505055,
      };
      const pointSize = 0.15;
      const spawnBounds = { xMin: -8, xMax: 8, zMin: -8, zMax: 8, yStart: 10 };
      const boundaryArea = {
        width: 20,
        height: 20,
        segmentsX: 80,
        segmentsZ: 80,
      };
      const clusterCenters = {
        0: new THREE.Vector3(-5, pointSize, -4),
        1: new THREE.Vector3(5, pointSize, -4),
        2: new THREE.Vector3(0, pointSize, 6),
      };
      const clusterSpread = 3.5;
      const randomSpread = 9.0;

      init();
      animate();

      function init() {
        console.log("Initializing Scene...");
        // Scene, Camera, Renderer setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 13, 15);
        camera.lookAt(0, 1, 0); // Look slightly above the origin (y=1)
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x15181f);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xa0b0c0, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 15, 8);
        scene.add(directionalLight);
        const hemisphereLight = new THREE.HemisphereLight(
          0xccccff,
          0x606090,
          0.4
        );
        scene.add(hemisphereLight);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2 + 0.2;
        controls.minDistance = 2;
        controls.maxDistance = 50;
        controls.target.set(0, 1, 0); // Ensure target matches lookAt

        // --- NEW: Enable Auto Rotation ---
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0; // Adjust speed as desired (default is 2.0)
        // Auto-rotation stops automatically on user interaction.
        // --- End Auto Rotation ---

        // Decision Boundary Plane
        createDecisionBoundaryPlane();

        // Event Listeners for Controls
        document
          .getElementById("kSlider")
          .addEventListener("input", handleKChange);
        setupPlaySpeedSlider();
        setupDataModeRadios();

        // Window Resize Listener (Only for Three.js canvas now)
        window.addEventListener("resize", onWindowResize);

        // Initial Data Load
        resetSeed();
        regenerateTrainingData(true);
      }

      // --- Helper function encapsulation ---
      function setupPlaySpeedSlider() {
        const playSpeedSlider = document.getElementById("playSpeedSlider");
        const playSpeedValueLabel = document.getElementById(
          "playSpeedValueLabel"
        );
        if (!playSpeedSlider || !playSpeedValueLabel) return; // Guard against missing elements if UI hidden
        playSpeedMultiplier = parseFloat(playSpeedSlider.value);
        currentFallSpeed = baseFallSpeed * playSpeedMultiplier;
        currentDisplayTime = Math.max(
          minDisplayTime,
          baseDisplayTime / playSpeedMultiplier
        );
        playSpeedValueLabel.textContent = playSpeedMultiplier.toFixed(2) + "x";

        playSpeedSlider.addEventListener("input", (event) => {
          playSpeedMultiplier = parseFloat(event.target.value);
          currentFallSpeed = baseFallSpeed * playSpeedMultiplier;
          currentDisplayTime = Math.max(
            minDisplayTime,
            baseDisplayTime / playSpeedMultiplier
          );
          playSpeedValueLabel.textContent =
            playSpeedMultiplier.toFixed(2) + "x";
        });
      }

      function setupDataModeRadios() {
        document.querySelectorAll('input[name="dataMode"]').forEach((radio) => {
          // Check if radio element actually exists in the DOM first
          if (radio && radio.parentElement) {
            radio.addEventListener("change", (event) => {
              if (event.target.checked) {
                trainingDataMode = event.target.value;
                console.log(
                  "Data Mode Changed To:",
                  trainingDataMode,
                  "- Regenerating..."
                );
                regenerateTrainingData(false);
              }
            });
          }
        });
      }
      // --- End Helper Functions ---

      // All other functions (createDecisionBoundaryPlane, handleKChange, regenerateTrainingData, etc.)
      // remain exactly the same as in the previous version.

      function createDecisionBoundaryPlane() {
        const geometry = new THREE.PlaneGeometry(
          boundaryArea.width,
          boundaryArea.height,
          boundaryArea.segmentsX,
          boundaryArea.segmentsZ
        );
        const material = new THREE.MeshBasicMaterial({
          vertexColors: true,
          side: THREE.DoubleSide,
        });
        boundaryPlaneMesh = new THREE.Mesh(geometry, material);
        boundaryPlaneMesh.rotation.x = -Math.PI / 2;
        boundaryPlaneMesh.position.y = -0.1;
        scene.add(boundaryPlaneMesh);
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        const defaultColor = new THREE.Color(classColors.boundaryUndefined);
        for (let i = 0; i < geometry.attributes.position.count; i++) {
          colors.set([defaultColor.r, defaultColor.g, defaultColor.b], i * 3);
        }
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      }

      function handleKChange(event) {
        // Check if element exists before accessing properties
        const kValueLabel = document.getElementById("kValueLabel");
        if (!kValueLabel) return;

        kValue = parseInt(event.target.value, 10);
        kValueLabel.textContent = kValue;
        setTimeout(() => {
          updateDecisionBoundary();
        }, 10);
      }

      function regenerateTrainingData(isInitialSetup = false) {
        console.log("Regenerating data and boundary...");
        clearTrainingPoints();
        cleanupFallingPoint();
        clearVoteLines();
        resetSeed();
        addInitialTrainingData(20);
        setTimeout(() => {
          updateDecisionBoundary();
          spawnFallingTestPoint();
        }, 50);
      }

      function clearTrainingPoints() {
        console.log("Clearing training points...");
        trainingPoints.forEach((tp) => {
          if (tp.mesh) {
            scene.remove(tp.mesh);
            if (tp.mesh.geometry) tp.mesh.geometry.dispose();
            if (tp.mesh.material) tp.mesh.material.dispose();
          }
        });
        trainingPoints.length = 0;
      }

      function cleanupFallingPoint() {
        if (fallingTestPoint && fallingTestPoint.mesh) {
          clearTimeout(fallingTestPoint.removeTimer);
          scene.remove(fallingTestPoint.mesh);
          if (fallingTestPoint.mesh.geometry)
            fallingTestPoint.mesh.geometry.dispose();
          if (fallingTestPoint.mesh.material)
            fallingTestPoint.mesh.material.dispose();
        }
        fallingTestPoint = null;
      }

      function addInitialTrainingData(pointsPerClass) {
        console.log(`Generating Training Data (Mode: ${trainingDataMode})...`);
        const totalPoints = pointsPerClass * 3;
        for (let i = 0; i < totalPoints; i++) {
          let pos, classId;
          if (trainingDataMode === "grouped") {
            classId = Math.floor(i / pointsPerClass);
            const center = clusterCenters[classId];
            const offsetX = (seededRandom() - 0.5) * clusterSpread * 2;
            const offsetZ = (seededRandom() - 0.5) * clusterSpread * 2;
            pos = new THREE.Vector3(
              center.x + offsetX,
              pointSize,
              center.z + offsetZ
            );
          } else {
            const x = (seededRandom() - 0.5) * randomSpread * 2;
            const z = (seededRandom() - 0.5) * randomSpread * 2;
            pos = new THREE.Vector3(x, pointSize, z);
            classId = Math.floor(seededRandom() * 3);
          }
          addPoint(pos, classId);
        }
        console.log(`Generated ${trainingPoints.length} training points.`);
        updateKSliderMax();
      }

      function addPoint(position, classId) {
        const geometry = new THREE.SphereGeometry(pointSize, 20, 20);
        const color = classColors[classId];
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.2,
          roughness: 0.6,
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        sphere.position.y = Math.max(sphere.position.y, pointSize);
        scene.add(sphere);
        trainingPoints.push({
          position: sphere.position,
          class: classId,
          mesh: sphere,
        });
        return sphere;
      }

      function spawnFallingTestPoint() {
        cleanupFallingPoint();
        clearVoteLines();
        const x =
          (seededRandom() - 0.5) * (spawnBounds.xMax - spawnBounds.xMin);
        const z =
          (seededRandom() - 0.5) * (spawnBounds.zMax - spawnBounds.zMin);
        const startPos = new THREE.Vector3(x, spawnBounds.yStart, z);
        const geometry = new THREE.SphereGeometry(pointSize * 1.1, 20, 20);
        const material = new THREE.MeshStandardMaterial({
          color: classColors.testFalling,
          metalness: 0.3,
          roughness: 0.5,
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(startPos);
        scene.add(sphere);
        fallingTestPoint = {
          mesh: sphere,
          targetY: pointSize,
          falling: true,
          removeTimer: null,
        };
      }

      function getKNNPrediction(testPosition, k) {
        if (trainingPoints.length === 0)
          return { predictedClass: -1, neighbors: [] };
        const distances = trainingPoints.map((trainPoint) => ({
          point: trainPoint,
          distance: testPosition.distanceTo(trainPoint.position),
        }));
        distances.sort((a, b) => a.distance - b.distance);
        const currentK = Math.min(k, trainingPoints.length);
        const neighbors = distances.slice(0, currentK);
        if (neighbors.length === 0)
          return { predictedClass: -1, neighbors: [] };
        const votes = { 0: 0, 1: 0, 2: 0 };
        neighbors.forEach((neighbor) => votes[neighbor.point.class]++);
        let predictedClass = -1,
          maxVotes = 0,
          tiedClasses = [];
        for (const classId in votes) {
          if (votes[classId] > maxVotes) {
            maxVotes = votes[classId];
            predictedClass = parseInt(classId, 10);
            tiedClasses = [predictedClass];
          } else if (votes[classId] === maxVotes) {
            tiedClasses.push(parseInt(classId, 10));
          }
        }
        if (tiedClasses.length > 1) {
          for (let i = 0; i < neighbors.length; i++) {
            if (tiedClasses.includes(neighbors[i].point.class)) {
              predictedClass = neighbors[i].point.class;
              break;
            }
          }
          if (!tiedClasses.includes(predictedClass)) {
            predictedClass = Math.min(...tiedClasses);
          }
        }
        return { predictedClass, neighbors: neighbors.map((n) => n.point) };
      }

      function updateDecisionBoundary() {
        if (
          !boundaryPlaneMesh?.geometry?.attributes?.position ||
          !boundaryPlaneMesh?.geometry?.attributes?.color
        )
          return;
        const geometry = boundaryPlaneMesh.geometry;
        const positions = geometry.attributes.position;
        const colors = geometry.attributes.color;
        const tempTestPos = new THREE.Vector3();
        const matrixWorld = boundaryPlaneMesh.matrixWorld;
        const hasPoints = trainingPoints.length > 0;
        const currentKValue = document.getElementById("kSlider")
          ? parseInt(document.getElementById("kSlider").value, 10)
          : kValue; // Get current slider value safely

        for (let i = 0; i < positions.count; i++) {
          tempTestPos.fromBufferAttribute(positions, i);
          tempTestPos.applyMatrix4(matrixWorld);
          tempTestPos.y = 0;
          let predictedClass = -1;
          // Use currentKValue safely retrieved
          if (hasPoints) {
            predictedClass = getKNNPrediction(
              tempTestPos,
              currentKValue
            ).predictedClass;
          }
          let boundaryColor;
          switch (predictedClass) {
            case 0:
              boundaryColor = classColors.boundary0;
              break;
            case 1:
              boundaryColor = classColors.boundary1;
              break;
            case 2:
              boundaryColor = classColors.boundary2;
              break;
            default:
              boundaryColor = classColors.boundaryUndefined;
          }
          const colorObj = new THREE.Color(boundaryColor);
          colors.setXYZ(i, colorObj.r, colorObj.g, colorObj.b);
        }
        colors.needsUpdate = true;
      }

      function classifyLandedPoint(landedPointData) {
        const classificationResult = getKNNPrediction(
          landedPointData.mesh.position,
          kValue
        );
        const { predictedClass, neighbors } = classificationResult;
        if (predictedClass !== -1) {
          if (landedPointData.mesh?.material) {
            landedPointData.mesh.material.color.set(
              classColors[`testPredicted${predictedClass}`]
            );
          }
        } else {
          if (landedPointData.mesh?.material) {
            landedPointData.mesh.material.color.set(
              classColors.testLandedNeutral
            );
          }
        }
        drawVoteLines(landedPointData.mesh.position, neighbors);
        landedPointData.removeTimer = setTimeout(() => {
          spawnFallingTestPoint();
        }, currentDisplayTime);
      }

      function drawVoteLines(targetPosition, neighborPoints) {
        clearVoteLines();
        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 1.5,
          transparent: false,
        });
        neighborPoints.forEach((neighbor) => {
          const points = [targetPosition.clone(), neighbor.position.clone()];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geometry, material);
          scene.add(line);
          voteLines.push(line);
        });
      }

      function clearVoteLines() {
        voteLines.forEach((line) => {
          scene.remove(line);
          line.geometry?.dispose();
          line.material?.dispose();
        });
        voteLines.length = 0;
      }

      function updateKSliderMax() {
        const kSlider = document.getElementById("kSlider");
        const kValueLabel = document.getElementById("kValueLabel");
        if (!kSlider || !kValueLabel) return; // Check elements exist

        const maxK = Math.max(1, trainingPoints.length);
        kSlider.max = maxK;
        let currentSliderValue = parseInt(kSlider.value);

        if (currentSliderValue > maxK) {
          kSlider.value = maxK;
          currentSliderValue = maxK; // Update tracked value
        }
        if (kValue > maxK) {
          kValue = maxK;
        } else if (trainingPoints.length === 0) {
          kSlider.value = 1;
          currentSliderValue = 1;
          kValue = 1;
        }
        // Update variable kValue based on potentially clamped slider value
        kValue = currentSliderValue;
        kValueLabel.textContent = kValue; // Ensure label matches
      }

      // This function now only handles the Three.js canvas resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate(time) {
        requestAnimationFrame(animate);
        controls.update(); // REQUIRED for auto-rotate, damping
        if (fallingTestPoint && fallingTestPoint.falling) {
          const currentY = fallingTestPoint.mesh.position.y;
          const targetY = fallingTestPoint.targetY;
          if (currentY > targetY) {
            fallingTestPoint.mesh.position.y = Math.max(
              targetY,
              currentY - currentFallSpeed
            );
          }
          if (
            fallingTestPoint.mesh.position.y <= targetY &&
            fallingTestPoint.falling
          ) {
            fallingTestPoint.mesh.position.y = targetY;
            fallingTestPoint.falling = false;
            classifyLandedPoint(fallingTestPoint);
          }
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
